package com.arc.paddleRoyale.view.cluster{		import com.arc.paddleRoyale.controller.App;	import com.arc.paddleRoyale.model.AgencyEvent;	import com.arc.paddleRoyale.model.AppEvent;	import com.arc.paddleRoyale.vo.Agency;	import com.arc.paddleRoyale.vo.Colors;	import com.arc.paddleRoyale.vo.Constants;	import com.arc.paddleRoyale.vo.Player;	import com.arc.utils.DisplayUtils;	import com.arc.utils.MathUtils;	import com.carlcalderon.arthropod.Debug;	import com.greensock.TweenMax;		import fl.motion.Color;		import flash.display.GradientType;	import flash.display.InterpolationMethod;	import flash.display.MovieClip;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;		import shapes.Circle;		public class ClusterItem extends Circle	{		public static const DEFAULT_NAME:String = "com.arc.paddleRoyale.view.cluster.ClusterItem";/*--------------------------------------------------------------------------------------------------------		Vars--------------------------------------------------------------------------------------------------------*/		public 	var bg:MovieClip;		private var _expanded:Boolean 			= false;		private var _animTime:Number			= 4;		public 	var players:MovieClip;		public 	var playersVector:Vector.<ClusterPlayerView> = new Vector.<ClusterPlayerView>();		private var _tweeningPlayers:Boolean 	= false;		// Text field		public 	var txtHolder:MovieClip;		private var _tf:TextFormat;		public 	var txt:TextField;					/*--------------------------------------------------------------------------------------------------------		Constructor--------------------------------------------------------------------------------------------------------*/		public function ClusterItem()		{			super();			addEventListener(Event.ADDED_TO_STAGE, onAddedToStageEvent);			addEventListener(Event.ENTER_FRAME, onEnterFrameEvent);			App.instance.addEventListener(AppEvent.LOAD_COMPLETE, onLoadComplete);		}						/*--------------------------------------------------------------------------------------------------------		Event Listeners--------------------------------------------------------------------------------------------------------*/		private function onAddedToStageEvent(event:Event):void		{			//Debug.log(DEFAULT_NAME.concat('onAddedToStageEvent(event:Event)'));			//Debug.log(DEFAULT_NAME.concat(".name: ", name));						//removeEventListener(Event.ADDED_TO_STAGE, onAddedToStageEvent);						txt						= txtHolder.txt;						_tf						= txt.getTextFormat();						txtHolder.mouseEnabled	=			txtHolder.mouseChildren	=			bg.mouseEnabled			= 			bg.mouseChildren		= false;						// Physics			this.fixedRotation		= false;			this.linearDamping		= 10;						// Random density			var f:Number 			= MathUtils.randomNumber(1, bg.totalFrames);			this.density 			= f;			bg.gotoAndStop(f);						// Hide players			players.scaleX			= 0;			players.scaleY			= 0;						var index:int			= int(name.slice(2)) - 1;						//Debug.log(DEFAULT_NAME.concat(".index: ", index));			//Debug.log(DEFAULT_NAME.concat(".App.instance.agencyCount: ", App.instance.agencyCount));						if(index < App.instance.agencyCount - 1)			{				agency				= App.instance.getAgencyByIndex(index);			}						// Dispatch so ClusterWorld knows we're ready			dispatchEvent(new Event(Event.COMPLETE));		}				public function kill():void		{			//DisplayUtils.removeDisplayObject(this);			destroy();			parent.removeChild(this);		}				private function onEnterFrameEvent (event:Event):void		{			txtHolder.rotation		= 0 - rotation;			// Rotate players slowy			if(_expanded && !_tweeningPlayers)			{				players.rotation	+= .5;			}		}				private function onLoadComplete($e:AppEvent):void		{			App.instance.removeEventListener(AppEvent.LOAD_COMPLETE, onLoadComplete);		}				private function onAgencyEvent($e:AgencyEvent):void		{			//Debug.log(DEFAULT_NAME.concat('onAgencyEvent($e:AgencyEvent)'));						switch($e.type)			{				case AgencyEvent.KNOCKED_OUT:					checkIfKnockedOut();					break;								default: break;			}		}						/*--------------------------------------------------------------------------------------------------------		Functions--------------------------------------------------------------------------------------------------------*/		private function varyScale():void		{			// Change scale			var min:int						= 8;			var max:int						= 12;			scaleX							= 			scaleY							= MathUtils.randomNumber(min, max) * .1;			redraw();		}				public function expand():void		{			hideShowPlayers(true);		}				public function compress():void		{			hideShowPlayers(false);		}				private function hideShowPlayers($show:Boolean):void		{			if($show == _expanded) return;			density							= $show ? 5 : 1 ;			_tweeningPlayers				= true;			_expanded						= $show;			var i:int						= 0;			var a:int						= $show ? 1 : 0 ;			var r:int						= $show ? 45 : 0;			var s:Number					= $show ? 1 : 0 ;			TweenMax.to(players, _animTime, {scaleX: s, scaleY: s, autoAlpha: a, rotation: r, onUpdate: redraw, onComplete: hideShowPlayers_Complete});						// Run through, tween individual players			var d:Number					= .05;			var ps:Number					= $show ? 1 : .1 ;			var iD:Number					= $show ? .5 : 0 ;			for each(var pl:ClusterPlayerView in playersVector) // 2 because there is the spacing sprite			{				TweenMax.to(pl, _animTime/playersVector.length, {autoAlpha: a, scaleX: ps, scaleY: ps, delay: iD + (d * i), onComplete: redraw});				i++;			}		}				public function hideShowPlayers_Complete():void		{			_tweeningPlayers				=  false;		}				private function assignPlayers():void		{			// Rotate players and assign player			var i:int						= 0;			var r:Number					= Math.round((bg.width - 5)/2);			var aI:Number 					= 360 / agency.playerCount;			//trace("angle increment: " + aI);			for each(var p:Player in agency.players)			{				var pl:ClusterPlayerView 	= new ClusterPlayerView();				var a:Number				= (aI * i);				//trace("angle: " + a);				pl.player					= p;				pl.rotation					= a;				pl.x 						= (r * Math.cos((a) * (Math.PI / 180)));				pl.y 						= (r * Math.sin((a) * (Math.PI / 180)));				pl.scaleX					=				pl.scaleY					= .1;				players.addChild(pl);				playersVector.push(pl);				i++;			}		}				private function checkIfKnockedOut():void		{			if(agency.knockedOut)			{				TweenMax.to(this, .5, {colorTransform: Constants.KNOCKED_OUT_COLOR_TRANSFORM});			}		}				private function drawBG():void		{			var matrix:Matrix				= new Matrix();			var type:String 				= GradientType.LINEAR;			var spread:String 				= SpreadMethod.PAD;			var interpolation:String 		= InterpolationMethod.LINEAR_RGB;			var alphas:Array 				= [ 1.0, 1.0 ];			var ratios:Array 				= [ 0, 255 ]; // Even spread			//var ratios:Array 				= [ 0, 205 ]; // From design... Not a fan			var c:Sprite					= new Sprite();			c.rotation						= 90;						matrix.createGradientBox(bg.width, bg.height, 0, 0, 0);						// Outline			//c.graphics.lineStyle(2,0x000000);						c.graphics.beginGradientFill(				type, 				Colors.gradientCollection[agency.index], 				alphas, 				ratios,				matrix, 				spread, 				interpolation			);						//c.graphics.drawRect( 0, 0, bg.width, bg.height );			c.graphics.drawCircle(0,0, 50);			c.graphics.endFill();						bg.addChild(c);			DisplayUtils.bringToBottom(c);		}				private function redraw():void		{			// Needed to make sure the physics world gets updated			this.destroy();				this.create();			this.circle();		}						/*--------------------------------------------------------------------------------------------------------		GETTER/SETTER--------------------------------------------------------------------------------------------------------*/		private var _agency:Agency;		public function get agency():Agency { return _agency; }		public function set agency($agency:Agency):void		{			_agency			= $agency;			text			= agency.name;			varyScale();			assignPlayers();			checkIfKnockedOut();			agency.addEventListener(AgencyEvent.KNOCKED_OUT, onAgencyEvent);			drawBG();			// Assign cluster item			_agency.clusterItem	= this;			redraw();		}				private var _defaultScale:Number;		public function get defaultScale():Number { return _defaultScale; }		public function set defaultScale($scale:Number):void		{			_defaultScale	= $scale;			scaleX			= _defaultScale;			scaleY			= _defaultScale;		}				override public function get scaleX():Number { return bg.scaleX; }		override public function set scaleX($scaleX:Number):void		{			bg.scaleX = $scaleX;			redraw();		}				override public function get scaleY():Number { return bg.scaleY; }		override public function set scaleY($scaleY:Number):void		{			bg.scaleY = $scaleY;			redraw();		}				public function get text():String { return txt.text; }		public function set text($text:String):void		{			//Debug.log(DEFAULT_NAME.concat(".set text: ", $text));			//Debug.log(DEFAULT_NAME.concat(' - txt: ', txt));			//Debug.log(DEFAULT_NAME.concat(' - _tf: ', _tf));						txt.autoSize					= TextFieldAutoSize.CENTER;			txt.text						= $text;			txt.setTextFormat(_tf);						//Debug.log(DEFAULT_NAME.concat(" - setting color"));			var c:Color 					= new Color();			c.setTint(agency.primaryColor, 1);			txt.transform.colorTransform 	= c;									//Debug.log(DEFAULT_NAME.concat(" - setting y"));			if(txt.numLines > 1)			{				var lh:int	= 14;				txt.y		= Math.round(0 - (txt.numLines * lh)/2);			}		}	}}