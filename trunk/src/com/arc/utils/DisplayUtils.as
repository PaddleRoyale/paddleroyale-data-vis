package com.arc.utils{	import com.arc.paddleRoyale.vo.Colors;		import flash.display.GradientType;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.geom.Matrix;
		public class DisplayUtils	{		/*		* Draw a segment of a circle		* @param target		<Sprite> The object we want to draw into		* @param x			<Number> The x-coordinate of the origin of the segment		* @param y 			<Number> The y-coordinate of the origin of the segment		* @param r 			<Number> The radius of the segment		* @param aStart		<Number> The starting angle (degrees) of the segment (0 = East)		* @param aEnd		<Number> The ending angle (degrees) of the segment (0 = East)		* @param step		<Number=1> The number of degrees between each point on the segment's circumference		*/				static public function drawSegment(target:Sprite, colorIndex:int, x:Number, y:Number, r:Number, aStart:Number, aEnd:Number, step:Number = 1):void		{			// More efficient to work in radians			var degreesPerRadian:Number 	= Math.PI / 180;			aStart 							*= degreesPerRadian;			aEnd 							*= degreesPerRadian;			step 							*= degreesPerRadian;						// Draw the segment			target.graphics.moveTo(x, y);						// Line on slice			target.graphics.lineStyle(1,0x000000, .75);						// Fill - Simple			//target.graphics.beginFill(color,1);						// File - Gradient			var mat:Matrix					= new Matrix();			//mat.createGradientBox(r, r, toRad(aEnd));									var xGrad:Number				= r * Math.cos(aEnd/2);			var yGrad:Number				= r * Math.sin(aEnd/2);						var c1:Number					= Colors.gradientCollection[colorIndex][0];			var c2:Number					= Colors.gradientCollection[colorIndex][1];			var offset:Number				= xGrad/Math.PI;						// Gradient - To the right - PREFERRED			mat.createGradientBox(r * 2,r * 2,degtoRad(r), 0, 0);						// Gradient - Center on outer ring			//mat.createGradientBox(r * 2,r * 2,degtoRad(r), xGrad - r, yGrad - r);						// Gradient - to the right - Very light			//mat.createGradientBox(r * Math.PI,r * Math.PI,degtoRad(r), xGrad - r, yGrad - r);									// Gradient - STRONG - to the right			//mat.createGradientBox(r,r,degtoRad(r), 0, 0);						// Begin fill			target.graphics.beginGradientFill(GradientType.RADIAL, [c2, c1],[1,1], [0,255], mat, SpreadMethod.PAD);						for (var theta:Number = aStart; theta < aEnd; theta += Math.min(step, aEnd - theta))			{				target.graphics.lineTo(x + r * Math.cos(theta), y + r * Math.sin(theta));			}			target.graphics.lineTo(x + r * Math.cos(aEnd), y + r * Math.sin(aEnd));			target.graphics.lineTo(x, y);						// End fill			target.graphics.endFill();						/*			// Testing xGrad,yGrad			target.graphics.beginFill(0xFFFFFF,1);			target.graphics.drawCircle(xGrad,yGrad,5);			target.graphics.endFill();			*/		}				static public function createShell(target:Sprite, colorIndex:int, data:Array):void		{			var multiplier:int		= 5;			var minimum:int			= 60;			var segment:Number		= 360/(data.length);			for( var i:int = 0 ; i < data.length ; i++)			{				//var start:Number 	= i * segment;				//var end:Number		= i == (data.length - 1) ? 0 : (i + 1) * segment;				var start:Number	= 0;				var end:Number		= segment;				var radius:Number	= (data[i] * multiplier) + minimum;				var slice:Sprite	= new Sprite();				slice.rotation		= i * segment;				target.addChild(slice);				var c:Colors				drawSegment(slice, colorIndex, 0, 0, radius, start, end);				//break;			}		}				/*		'toRad' helper function converts degrees to radians.		*/		static public function degtoRad(a:Number):Number {						return a*Math.PI/180;					}				public static function removeChildren($do:*):void		{			try			{				for ( var i:int = 0 ; i < $do.numChildren ; i++)				{					$do.removeChildAt(i);				}			}			catch( e:Error )			{				// Not a display object			}		}				static public function removeDisplayObject($obj:*):void		{			try			{				$obj.parent.removeChild($obj);			}			catch( e:Error )			{				// Not a display object, or doesn't have a parent			}		}				static public function bringToTop($do:*):void		{			try			{				$do.parent.setChildIndex( $do, ($do.parent.numChildren - 1));			}			catch(e:Error)			{				// Not a proper display object			}		}				static public function bringToBottom($do:*):void		{			try			{				$do.parent.setChildIndex( $do, (0));			}			catch(e:Error)			{				// Not a proper display object			}		}	}}